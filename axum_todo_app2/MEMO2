######################################################
### todo_handler.rs 
######################################################

// ✅ Todo を部分更新
async fn patch_todo<T: TodoService>(
    State(state): State<AppState<T>>,
    Path(id): Path<Uuid>,
    Json(payload): Json<PatchTodoRequest>, 
) -> impl IntoResponse {
    match state.todo_service.patch_todo(id, payload.completed).await {
        Ok(todo) => Json(TodoResponse::from(todo)).into_response(),
        Err(sqlx::Error::RowNotFound) => (StatusCode::NOT_FOUND, "Todo not found").into_response(),
        Err(_) => (StatusCode::INTERNAL_SERVER_ERROR, "Failed to update todo").into_response(),
    }
}


######################################################
### ./usecase/todo_usecase.rs
######################################################

    async fn patch_todo(&self, id: Uuid,  completed: bool) -> Result<Todo, sqlx::Error> {
        let existing_todo = self.repository.find_by_id(id).await?;
        if let Some(mut todo) = existing_todo {
            todo.completed = completed;
            return self.repository.update(todo).await;
        }
        Err(sqlx::Error::RowNotFound)
    }


######################################################
### repository.update
######################################################
    async fn update(&self, todo: Todo) -> Result<Todo, sqlx::Error> {
        let updated_todo = sqlx::query_as::<_, Todo>(
            "UPDATE todos SET title = $1, description = $2, completed = $3, updated_at = (NOW() AT TIME ZONE 'Asia/Tokyo')
             WHERE id = $4
             RETURNING id, title, description, completed, created_at, updated_at"
        )
        .bind(&todo.title)
        .bind(&todo.description)
        .bind(todo.completed)
        .bind(todo.id)
        .fetch_one(&self.pool)
        .await?;
        Ok(updated_todo)
    }



